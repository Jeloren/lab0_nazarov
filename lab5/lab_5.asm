; Директива для использования команд процессора 80386
.386

; Определение сегмента кода для COM-файла
CSEG SEGMENT PARA USE16 'CODE'
    ASSUME CS:CSEG, DS:CSEG, ES:CSEG

    ORG 100h

; --- Основная программа (для вызова и теста) ---
start:
    ; 1. Готовим параметры для вызова подпрограммы
    MOV AX, CS
    MOV ES, AX
    LEA DX, BIT_STRING  ; Загружаем в DX адрес нашей битовой строки

    MOV CX, BIT_LENGTH  ; Длина строки в битах

    ; 2. Вызываем подпрограмму
    CALL REVERSE_BITS

    ; 3. Завершаем программу
    INT 20h

; --- Данные для тестирования ---
BIT_STRING  DB 0B1h, 95h    ; Тестовая строка: 10110001 10010101b (16 бит)
BIT_LENGTH  EQU 16          ; Длина строки в битах

; =========================================================================
; ПОДПРОГРАММА: REVERSE_BITS (ОПТИМИЗИРОВАННЫЙ ВАРИАНТ)
; Назначение: Переворачивает битовую строку "задом наперёд".
; Вход:       ES:DX - адрес строки, CX - длина в битах.
; =========================================================================
REVERSE_BITS PROC NEAR
    PUSH CX
    PUSH SI
    PUSH DI
    PUSH BX
    PUSH AX             ; Сохраняем AX, т.к. будем использовать AL/AH

    MOV BX, DX          ; Используем BX для корректной адресации
    XOR SI, SI          ; Индекс первого бита
    MOV DI, CX
    DEC DI              ; Индекс последнего бита
    
    SHR CX, 1           ; Количество пар для обмена
    JBE done_reversing  ; Выход, если длина < 2

swap_loop:
    ; Эффективный алгоритм: инвертируем биты, только если они не равны.
    
    ; 1. Помещаем оба бита в регистр для сравнения, не используя стек.
    MOV AL, 0
    BT  ES:[BX], SI     ; Тестируем первый бит, результат в CF
    RCL AL, 1           ; Перемещаем бит из CF в AL (теперь AL = 0000000_start_bit)

    MOV AH, 0
    BT  ES:[BX], DI     ; Тестируем второй бит, результат в CF
    RCL AH, 1           ; Перемещаем бит из CF в AH (теперь AH = 0000000_end_bit)

    ; 2. Сравниваем биты.
    CMP AL, AH
    JE  no_swap_needed  ; Если биты равны, ничего не делаем, переходим к следующей итерации.

    ; 3. Если биты разные - инвертируем оба.
    ; Команда BTC (Bit Test and Complement) идеально подходит для этого.
    BTC ES:[BX], SI
    BTC ES:[BX], DI

no_swap_needed:
    ; 4. Сдвигаем указатели и переходим к следующей итерации.
    INC SI
    DEC DI
    LOOP swap_loop

done_reversing:
    POP AX
    POP BX
    POP DI
    POP SI
    POP CX
    RET
REVERSE_BITS ENDP
; =========================================================================

CSEG ENDS
END start