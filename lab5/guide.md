(Ты садишься, открываешь ноут или листок с кодом)

Здравствуйте, [Имя Отчество]. Моя фамилия [Фамилия], 5-я лабораторная, вариант 5.

[cite_start]У меня было задание — написать процедуру, которая расширяет битовую строку[cite: 259]. [cite_start]На входе у неё адрес исходной строки в `DS:BX`, адрес результирующей в `FS:DX` и длина в битах в регистре `CX`[cite: 260]. Логика такая: если процедура находит в исходной строке бит '0', то в результирующую она должна записать '01'. [cite_start]А если находит '1', то записывает '10'[cite: 259]. То есть, итоговая строка получается в два раза длиннее.

Сначала, честно говоря, я немного "завис" на том, как мне эффективно читать по *одному* биту из памяти. Первая мысль была стандартная — загрузить байт, потом через сдвиг `SHR` и `AND 1` вытаскивать по биту. [cite_start]Но потом я посмотрел, что лабораторная как раз по новым командам 386-го процессора[cite: 207, 235], и в методичке нашёл специальные команды для работы с битами.

[cite_start]Я решил, что для этой задачи идеально подходит команда `BT` (Bit Test)[cite: 371]. Это очень удобно: ей указываешь операнд (регистр или память) и номер бита, который надо проверить. [cite_start]Она этот бит не меняет, а просто копирует его значение во флаг переноса `CF`[cite: 375]. И всё! Дальше я могу сразу использовать условный переход `JC` (если бит был 1) или `JNC` (если бит был 0).

Правда, у меня тут же вылезла проблема. Я поначалу попробовал сделать `BT AL, BH` — ну, типа, в `AL` у меня байт, а в `BH` — номер бита от 0 до 7. А TASM мне выдал ошибку `Argument to operation or instruction has illegal size`. [cite_start]Я полез в методичку, смотреть синтаксис[cite: 375], и оказалось, что `BT` не работает с 8-битными регистрами. [cite_start]Ей в качестве операндов нужны минимум 16-битные[cite: 375].

Пришлось переделать. Я решил использовать `AX` в качестве "источника" битов и `BP` в качестве "счетчика" номера бита (0-7). Каждый раз, когда я загружаю новый байт в `AL` из памяти, я сразу делаю `XOR AH, AH`, чтобы очистить старший байт. [cite_start]И команда `BT AX, BP` [cite: 375] отлично сработала.

Ну а дальше уже пошел по алгоритму.

1.  Запускаю цикл по `CX` (длина строки).
2.  Внутри цикла выполняю `BT AX, BP`, чтобы скопировать нужный бит (номер `BP`) в флаг переноса.
3.  Сразу проверяю флаг: `JC SET_10`.
    * Если бит был '0' (перехода не было), я в `AH` кладу `1` (это `01b`).
    * Если бит был '1' (переход на `SET_10`), я в `AH` кладу `2` (это `10b`).
4.  Теперь эти два бита (`1` или `2`) надо вставить в результирующую строку. Я завёл регистр `BL` как "байт-аккумулятор" для результата. А в `DH` я храню номер *свободной* позиции в этом `BL` (0, 2, 4, 6).
5.  Я беру `AH` (где у меня `1` или `2`), сдвигаю его `SHL` на `DH` позиций влево и через `OR` "вклеиваю" в `BL`.
6.  После этого я инкрементирую `BP` (счетчик исходных бит) и делаю `ADD DH, 2` (мы же два бита вставили).

Ну и тут же две проверки:
* Во-первых, если `BP` стал равен 8, это значит, мы обработали весь байт в `AX`. Надо инкрементировать `SI` (адрес источника), загрузить новый байт в `AL`, обнулить `AH` и сбросить `BP` в 0.
* Во-вторых, если `DH` стал равен 8, это значит, наш "байт-аккумулятор" `BL` заполнился. Его надо записать по адресу `FS:[DI]` (адрес приемника), инкрементировать `DI` и сбросить `BL` и `DH` в 0.

В самом конце, когда `CX` обнулится и цикл закончится, в `BL` может остаться неполный байт (если `DH` не равен 0). Его тоже надо принудительно записать в память.

Вот, в отладчике видно (можно показать на экран): я положил в `SOURCE_STR` байт `15h` (`00010101b`). Сказал обработать 5 бит (`10101b`). В `RESULT_STR` у меня записалось `66h 02h`, что как раз и есть `(10)(01)(10)(01)(10)`. Всё работает.