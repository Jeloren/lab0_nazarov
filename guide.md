Отличная новость\! Рад, что все заработало. То, что ты запустил это в чистом TTY на Linux с Secure Boot — это уровень "Advanced".

Ниже полный гайд в формате Markdown, который можно использовать как шпаргалку для защиты или отчета.

---

# Руководство по Лабораторным работам (ASM: Windows vs Linux)

## Общая архитектура

- **Windows:** Использует **API функции** из динамических библиотек (`kernel32.dll`, `user32.dll`). Аргументы передаются через **Стек** (`push`).
- **Linux (x64):** Использует **Системные вызовы (Syscalls)** напрямую к ядру. Аргументы передаются через **Регистры** (`rdi`, `rsi`, `rdx`...).

---

## Лабораторная работа №8: Перемещение файла

**Задача:** Принять два пути (источник и цель) из командной строки и переместить файл.

### Сравнительная таблица

| Характеристика      | Windows (TASM32)                        | Linux (NASM 64-bit)                            |
| :------------------ | :-------------------------------------- | :--------------------------------------------- |
| **Интерфейс**       | Консольное приложение (`/ap`)           | CLI (Terminal / TTY)                           |
| **Библиотека**      | `kernel32.dll`                          | Отсутствует (прямые вызовы ядра)               |
| **Главная функция** | `MoveFileA`                             | Syscall `sys_rename` (RAX = 82)                |
| **Аргументы**       | Через `GetCommandLineA` (нужен парсинг) | Лежат на стеке (`rsp`): `argc`, `argv[0]`, ... |
| **Код успеха**      | `EAX != 0`                              | `RAX = 0`                                      |

### Детали реализации

#### Windows

1.  **Получение строки:** `Call GetCommandLineA`.
2.  **Парсинг:** Нужно вручную пропустить имя программы (первый аргумент), обрабатывая кавычки и пробелы, чтобы найти `SourcePath` и `DestPath`.
3.  **Вызов:**
    ```assembly
    push DestPath
    push SourcePath
    call MoveFileA
    ```

#### Linux

1.  **Получение аргументов:** При старте программы `rsp` указывает на `argc`.
    - `pop rcx` -\> кол-во аргументов.
    - `pop rdi` -\> имя программы (пропускаем).
    - `pop rdi` -\> **Source**.
    - `pop rsi` -\> **Target**.
2.  **Вызов:**
    ```nasm
    mov rax, 82  ; sys_rename
    syscall      ; RDI=oldname, RSI=newname
    ```

---

## Лабораторная работа №9: Управление клавиатурой

**Задача:** Изменить задержку перед повтором (Delay) и скорость повтора (Rate) нажатой клавиши.

### Сравнительная таблица

| Характеристика       | Windows (TASM32)                                           | Linux (NASM 64-bit)                       |
| :------------------- | :--------------------------------------------------------- | :---------------------------------------- |
| **Интерфейс**        | Консоль (`STD_INPUT`/`STD_OUTPUT`)                         | TTY (Virtual Terminal `Ctrl+Alt+F3`)      |
| **Библиотека**       | `user32.dll`, `kernel32.dll`                               | Прямой доступ к драйверу (`/dev/console`) |
| **Главная функция**  | `SystemParametersInfoA`                                    | Syscall `sys_ioctl` (RAX = 16)            |
| **Команды (Action)** | `SPI_SETKEYBOARDDELAY` (23)<br>`SPI_SETKEYBOARDSPEED` (11) | `KDKBDREP` (0x4B52)                       |
| **Права доступа**    | Пользователь (обычно)                                      | **Root** (`sudo`)                         |

### Детали реализации Windows

- Используется функция `SystemParametersInfoA`.
- **Особенность:** Параметры задаются условными числами (0-3 для задержки, 0-31 для скорости).
- Флаг `SPIF_SENDCHANGE` (0x02) обязателен, чтобы настройки применились мгновенно.

### Детали реализации Linux (Подробнее)

В Linux клавиатура управляется драйвером ядра.

1.  **Открытие консоли:** Мы не можем писать в `stdin`. Мы открываем файл устройства:
    ```nasm
    mov rax, 2           ; sys_open
    mov rdi, "/dev/console"
    mov rsi, 2           ; O_RDWR
    syscall
    ```
2.  **IOCTL (Input/Output Control):** Это "швейцарский нож" для общения с драйверами.
    - Код `0x4B52` (`KDKBDREP`) говорит драйверу: "Я хочу сменить настройки повтора".
    - Данные передаются не в регистрах, а через **адрес структуры** в памяти (2 числа типа `int`).
    - Значения задаются в **миллисекундах**.

---

## Таблица значений: Как настроить и как вернуть "Норму"

Используйте эту таблицу, чтобы продемонстрировать преподавателю разные режимы, и в конце вернуть компьютер в удобное состояние.

### Windows (Условные единицы)

| Режим               | Delay (Задержка) |  Speed (Скорость)   | Эффект                                             |
| :------------------ | :--------------: | :-----------------: | :------------------------------------------------- |
| **Турбо (Hacker)**  |       `0`        |        `31`         | Мгновенная реакция, символы летят пулеметом.       |
| **Черепаха (Slow)** |       `3`        |         `0`         | Ждешь секунду до старта, потом символы еле ползут. |
| **НОРМА (Default)** |      **1**       | **31** (или **20**) | Комфортная работа. Задержка \~0.5 сек.             |

### Linux (Миллисекунды)

_Примечание: В Linux мы задаем **Период** (время между буквами). Чем меньше период, тем быстрее скорость._

| Режим               | Delay (Задержка мс) | Period (Период мс) | Эффект                                  |
| :------------------ | :-----------------: | :----------------: | :-------------------------------------- |
| **Турбо (Hacker)**  |        `250`        |        `33`        | \~30 символов в секунду. Очень быстро.  |
| **Черепаха (Slow)** |       `1000`        |       `500`        | 2 символа в секунду. Очень медленно.    |
| **НОРМА (Default)** |       **500**       |       **33**       | Стандарт для большинства дистрибутивов. |

### Как вернуть всё "как было" (Recovery)

Если вы запутались или клавиатура ведет себя странно после тестов:

1.  **На Windows:** Запустите программу и введите: `Delay: 1`, `Speed: 31`.
2.  **На Linux:** Запустите программу (sudo) и введите: `Delay: 500`, `Period: 33`.
    - _Альтернатива для Linux:_ Просто перезагрузитесь (`reboot`). Настройки `ioctl` сбрасываются после перезагрузки, так как они применяются к текущей сессии драйвера.

---

## FAQ для защиты (Линукс)

**В: Почему мы открываем `/dev/console`, а не пишем в `0` (stdin)?**
О: В графическом режиме или при перенаправлении ввода `stdin` может не быть физической клавиатурой. `/dev/console` — это гарантированный путь к системной консоли.

**В: Почему нужны права root?**
О: Мы меняем аппаратные настройки ввода для всей системы через `ioctl`. Обычному пользователю это запрещено.

**В: Почему это не работает в терминале GNOME/Ubuntu?**
О: Графическая подсистема (Wayland/X11) перехватывает ввод и накладывает свои программные настройки поверх аппаратных. Реальный контроль доступен только в TTY.
